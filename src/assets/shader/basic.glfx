program:
  precision highp float;
  precision highp int;

  #include <lib/common.h>
  #include <lib/lighting.h> 

  // @binding position
  attribute vec3 aPosition;
  // @binding normal
  attribute vec3 aNormal;
  // @binding texture
  attribute vec2 aTexture;
    
  varying vec3 Position;
  varying vec3 Normal;
  varying vec2 TexCoord;
  varying vec3 DiffuseTerm;
  varying vec3 SpecularTerm;

technique:
  name: basic
  pass:
    vertexShader:
      void main(void) {
        vec4 pos = WorldMat4 * vec4(aPosition, 1.0);
        gl_Position = ProjectionMat4 * ViewMat4 * pos;
        
        TexCoord = aTexture;
      }

    fragmentShader:
      void main(void) {
        vec4 color = GetDiffuseColor(TexCoord);
        gl_FragColor = color;
      }

technique:
  name: vertexLighting
  pass:
    vertexShader:
      void main(void) {
        vec4 pos = WorldMat4 * vec4(aPosition, 1.0);
        vec3 nrm = mat3(WorldMat4) * aNormal;
        gl_Position = ProjectionMat4 * ViewMat4 * pos;
        
        CalculateLightTerms(pos.xyz, normalize(nrm), SpecularPower, DiffuseTerm, SpecularTerm);
        TexCoord = aTexture;
      }

    fragmentShader:
      void main(void) {
        vec4 color = GetDiffuseColor(TexCoord);
        gl_FragColor = vec4(DiffuseTerm.rgb * color.rgb + SpecularTerm.rgb * SpecularColor.rgb + AmbientColor.rgb, color.a);
      }
     
technique:
  name: pixelLighting
  pass:
    vertexShader:
      void main(void) {
        vec4 pos = WorldMat4 * vec4(aPosition, 1.0);
        gl_Position = ProjectionMat4 * ViewMat4 * pos;
        
        Position = pos.xyz;
        TexCoord = aTexture * vec2(1, -1);
        Normal = mat3(WorldMat4) * aNormal;
      }

    fragmentShader:
      void main(void) {
        vec4 color = GetDiffuseColor(TexCoord);
        
        vec3 dTerm;
        vec3 sTerm;
        CalculateLightTerms(Position.xyz, normalize(Normal), SpecularPower, dTerm, sTerm);
        
        gl_FragColor = vec4(dTerm * color.rgb + sTerm * SpecularColor + AmbientColor, color.a);
      }
