//- title: Rectangle colored (improved)
//- weight: 4
extends ./../../_layouts/example
block script
  a(name="HTML" index=3)
  viewcode
  
  a(name="GLSL" index=2)
  .grid-content
    dl.mt.no-mb
      dt Vertex shader
      dd.no-mb 
        | The vertex shader again uses the vertex position without any transformation.
        | Additionally passes the vertex color to the fragment stage

  script#vertex-shader(type='text/glsl').
    precision highp float;
    attribute vec3 vPosition;
    attribute vec3 vColor;
    varying vec3 vertexColor;
    void main(void) {
      vertexColor = vColor;
      gl_Position = vec4(vPosition, 1.0);
    }

  .grid-content
    dl.mt.no-mb
      dt Fragment shader
      dd.no-mb 
        | Takes the vertex color from the fragment stage and renders the pixel with that color.

  script#fragment-shader(type='text/glsl').
    precision highp float;
    varying vec3 vertexColor;
    void main(void) {
      gl_FragColor = vec4(vertexColor.rgb, 1.0);
    }
    
  a(name="JS" index=1)
  .grid-content
    dl.mt.no-mb
      dt Remarks
      dd.no-mb 
        | The example is almost completely identical to the colored rectangle example.
        | The improvement is that the color attribute of the vertex buffer is packed
        | into a single value. 
  script(type='text/javascript').
    var device = new Glib.Graphics.Device({
      canvas: document.getElementById('canvas')
    });
    var program = device.createProgram({
      vertexShader: document.getElementById('vertex-shader').textContent,
      fragmentShader: document.getElementById('fragment-shader').textContent
    });
    
    var vertices = device.createVertexBuffer({
      layout: {
        // The 'vPosition' layout is still the same
        vPosition: { type: "float", offset: 0, elements: 3  },
        // The 'vColor' is now defined as 4 ubyte elements
        // All elements are packed into a single uint value 
        vColor: { 
          type: "ubyte", 
          offset: 12, 
          elements: 4, 
          // this indicates that the 4 elements are packed in a single value
          packed: true,   
          // this indicates that a byte value should be normalized 
          // into [0:1] range before it is utilized in the vertex shader stage
          normalize: true 
        }
      },
      
      data: [
      //  X  |  Y  | Z        A B G R
        -0.5, -0.5, 0.0,   0xFF0000FF, // The red vertex   (color is packed)
         0.5, -0.5, 0.0,   0xFF00FF00, // The green vertex (color is packed)
        -0.5,  0.5, 0.0,   0xFFFF0000, // The blue vertex  (color is packed)
         0.5,  0.5, 0.0,   0xFFFFFFFF  // The white vertex (color is packed)
      ]
    });

    var indices = device.createIndexBuffer({
      type: 'ushort',
      data: [0, 1, 2, 1, 2, 3]
    });

    Glib.utils.loop(function() {
      device.resize();
      device.clear(Glib.Color.CornflowerBlue);
      
      device.program = program;
      device.vertexBuffer = vertices;

      // Also set the index buffer
      device.indexBuffer = indices;
      // Now call drawIndexedPrimitives. This is similar to 'drawPrimitives'
      // but utilizes the index buffer.
      device.drawIndexedPrimitives('TriangleList', 0, 6);
    });
