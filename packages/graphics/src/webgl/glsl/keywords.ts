export const Keywords = {
  all: new Set<string>([]),
  simpleTypes: new Set([
    'void',
    'bool',
    'int',
    'uint',
    'float',
    'double',
    'half',
    'long',
    'short',
    'bvec2',
    'bvec3',
    'bvec4',
    'dvec2',
    'dvec3',
    'dvec4',
    'fvec2',
    'fvec3',
    'fvec4',
    'hvec2',
    'hvec3',
    'hvec4',
    'ivec2',
    'ivec3',
    'ivec4',
    'uvec2',
    'uvec3',
    'uvec4',
    'vec2',
    'vec3',
    'vec4',
    'mat2',
    'mat2x2',
    'mat2x3',
    'mat2x4',
    'mat3',
    'mat3x2',
    'mat3x3',
    'mat3x4',
    'mat4',
    'mat4x2',
    'mat4x3',
    'mat4x4',
  ]),

  samplerTypes: new Set([
    'isampler1D',
    'isampler1DArray',
    'isampler2D',
    'isampler2DArray',
    'isampler2DMS',
    'isampler2DRect',
    'isampler3D',
    'isamplerBuffer',
    'isamplerCube',
    'sampler1D',
    'sampler1DArray',
    'sampler1DArrayShadow',
    'sampler1DShadow',
    'sampler2D',
    'sampler2DArray',
    'sampler2DArrayShadow',
    'sampler2DMS',
    'sampler2DRect',
    'sampler2DRectShadow',
    'sampler2DShadow',
    'sampler3D',
    'sampler3DRect',
    'samplerBuffer',
    'samplerCube',
    'samplerCubeShadow',
    'usampler1D',
    'usampler1DArray',
    'usampler2D',
    'usampler2DArray',
    'usampler2DMS',
    'usampler2DRect',
    'usampler3D',
    'usamplerBuffer',
    'usamplerCube',
  ]),

  invariant: new Set(['invariant']),

  interpolationQualifier: new Set([
    'centroid',
    'smooth',
    'flat',
  ]),

  layout: new Set(['layout']),

  storageQualifier: new Set([
    'const',
    'in',
    'out',
    'uniform',
    'varying',
    'attribute',
  ]),

  precisionQualifier: new Set([
    'lowp',
    'mediump',
    'highp',
  ]),

  memoryQualifier: new Set([
    'coherent',
    'volatile',
    'readonly',
    'restrict',
    'writeonly',
  ]),

  boolean: new Set([
    'true',
    'false',
  ]),

  struct: new Set(['struct']),

  controlFlow: new Set([
    'switch',
    'case',
    'break',
    'continue',
    'default',
    'for',
    'do',
    'while',
    'if',
    'else',
    'goto',
    'return',
  ]),

  unclassified: new Set([
    'active',
    'asm',
    'atomic_uint',

    'common',
    'discard',
    'extern',
    'external',

    'filter',
    'fixed',
    'precision',
  ]),

  reserved: new Set([
    'class',
    'enum',
    'interface',

    'iimage1D',
    'iimage1DArray',
    'iimage2D',
    'iimage2DArray',
    'iimage3D',
    'iimageBuffer',
    'iimageCube',
    'image1D',
    'image1DArray',
    'image2D',
    'image2DArray',
    'image3D',
    'imageBuffer',
    'imageCube',
    'uimage1D',
    'uimage1DArray',
    'uimage2D',
    'uimage2DArray',
    'uimage3D',
    'uimageBuffer',
    'uimageCube',

    'inline',
    'noinline',
    'inout',
    'input',
    'output',

    'noperspective',

    'partition',
    'patch',
    'public',
    'resource',
    'sample',
    'static',
    'subroutine',
    'superp',
    'template',
    'this',
    'typedef',
    'union',
    'unsigned',
  ])
}

Object.keys(Keywords).forEach((key) => {
  Keywords[key].forEach((word: string) => {
    Keywords.all.add(word)
  })
})
